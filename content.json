{"pages":[{"title":"","text":"个人简介 从核工程到入门码农。技术很菜，希望技术能随着博客的运营一起成长但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：软件工程C++、UE4研究生一枚坚信代码改变生活 博客信息 网站采用的Icarus主题 Github page + Hexo + amazing theme 感谢原作者 removeif 更新日志：–2021.6.3：Hillock建立啦 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 其他 也许未来会有呢 计划2021计划 2021-GOALS 做好自己课题 计网、操作系统、leetcode每日学习 时间轴记录","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/06/02/hello-world/"},{"title":"软件测试————基础","text":"软件缺陷错误(error) 人们在开发软件过程中发生的过错； 是一种认为的过程，对于软件本身是一种外部行为。 缺陷(defect) 错误在程序中的表现； 存在于软件中不希望或不可接受的偏差； 当缺陷被激活时，会发生软件故障； 常用Bug指代缺陷。 故障(fault) 软件运行过程中出现的不希望/不可接受的内部状态； 软件丧失了在规定的限度内执行所需功能的能力； 故障是动态的，可能会导致失效； 故障是软件缺陷的内在表现。 失效(failure) 软件运行时出现的不希望/不可接受的外部行为结果； 系统行为对用户预期的偏离； 失效是软件缺陷的外在表现，只有运行中的软件才可能发生失效； 失效可能会带来事故。 错误 产生 缺陷 引起 故障 导致 失效","link":"/2021/06/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951/"},{"title":"软件测试——黑盒技术","text":"边界值分析边界值选择的基本原则（1）如果输入条件规定了取值范围，则以此范围为基础设计测试用例。（2）如果输入条件指定了取值的个数，则以个数为基础设计测试用例。（3）如果需求规格说明中制定了输出的范围和取之的个数，参考（1）（2）。（4）如果输入或输出是一个有序集合，如线性表、顺序文件等，则选择该序列中的第一个以及最后一个元素进行测试。 边界值测试用例设计对于一个有明确范围的输入或输出，选择最小值、略大于最小值、正常值、略小于最大值和最大值进行测试，分别标记为min,min+.normal,max-,max. 输入域边界值测试普通边界值测试普通边界值测试基于单缺陷假设，只考虑输入取有效值的情况。在设计测试用例时，同一时刻只有一个变量取极值，而其他变量取正常值。 例1 x取[a,b],y取[c,d],则测试用例为{[(a+b)/2,c],[(a+b)/2,c+1],[(a+b)/2,d-1],[(a+b)/2,d],[a,(c+d)/2],[a+1,(c+d)/2],[b-1,(c+d)/2],[b,(c+d)/2]}对于具有n个输入的程序，采用普通边界值测试技术，可以产生4n+1个测试用例。 健壮性测试健壮性测试基于单缺陷夹着，既考虑输入取有效值也考虑输入取无效值的情况。在设计测试用例时，同一时间只有一个变量取极值，而其他变量取正常值。 对于例1中的情况，测试用例增加{[(a+b)/2,c-1],[(a+b)/2,d+1],[a-1,(c+d)/2],[b+1,(c+d)/2]}对于具有n个输入的程序，采用健壮性测试技术，可以产生6n+1个测试用例。 最坏情况测试最坏情况测试基于多缺陷假设，只考虑输入取有效值的情况，在设计测试用例时，同一时刻允许多个变量取极值，但每个变量只考虑有效输入情况。 针对例1，需要测试的组合为{a,a+1,(a+b)/2,b-1,b}和{c,c+1,(c+d)/2,d-1,d}的笛卡尔乘积。对于具有n个输入的程序，采用最坏情况测试，可以产生5^n个测试用例。 健壮最坏情况测试健壮最坏情况测试基于多缺陷假设，只考虑输入取有效值的情况，在设计测试用例时，同一时刻允许多个变量取极值，每个变量综合考虑有效输入情况和无效输入情况。 针对例1，需要测试的组合为{a-1,a,a+1,(a+b)/2,b-1,b,b+1}和{c-1,c,c+1,(c+d)/2,d-1,d,d+1}的笛卡尔乘积。对于具有n个输入的程序，采用最坏情况测试，可以产生7^n个测试用例。 等价类测试等价类划分法是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。 等价类划分原则 有效等价类:是指对于程序的规格说明来说是合理的,有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。 无效等价类:与有效等价类的定义相反。 (1)如果输入条件规定了一个取值范围[a,b],则可以确定一个有效等价类[a,b],两个无效等价类x&lt;a,x&gt;b.(2)如果输入条件规定了取值个数n,则可以确定一个有效等价类[1,n],两个无效等价类x&lt;1,x&gt;n.(3)在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类.(4)在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类. 布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和 false 。(5)在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类.例：输入条件说明输入字符为:中文、英文、阿拉伯文三种之一，则分别取这三种这三个值作为三个有效等价类，另外把三种字符之外的任何字符作为无效等价类。(6)在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。 等价类测试流程确定等价关系将输入分为有效等价类和无效等价类。 生成测试用例 给每个等价类设置一个不同的编号 编写一个新的测试用例，尽可能的包含还未被覆盖的有效等价类，当所有有效等价类都被覆盖之后，进入下个步骤 编写一个新的测试用例，一次只能包含一个还未被覆盖的无效等价类，当所有无效等价类都被覆盖之后结束。 扩展的等价类测试(1)弱一般等价类测试只考虑有效等价类，不考虑无效等价类，基于单缺陷假设，具体方法为：写一个新的测试用例，尽可能的包含还未被覆盖的有效等价类，直到所有有效等价类都被覆盖。(2)强一般等价类测试只考虑有效等价类，不考虑无效等价类，基于多缺陷假设，具体方法为：考虑每个输入的有效等价类之间的组合。(3)弱健壮等价类测试考虑有效等价类，无效等价类，基于单缺陷假设，就是传统的等价类测试。(4)强健壮等价类测试考虑有效等价类，无效等价类，基于多缺陷假设，考虑每个输入的有效等价类和无效等价类之间的组合。","link":"/2021/06/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%952/"},{"title":"专业面面经汇总（1）","text":"专业面面经汇总（1）1.大小端 大端存储：数据的高字节存储在低地址中； 小端存储：数据的低字节存储在低地址中； 0x1234： 低字节为0x34,高字节为0x12; 2.进程间通信 共享内存：效率高； 消息队列； 管道：无名管道，有名管道； socket：多用于网络中，也可用于进程中。 信号，信号量；3.指针和引用的区别 指针：指针是一个变量，值为目标存储的地址，可以为空，初始化时也可以为空。指针可以有多级。 引用：是目标的别名，必须初始化且不能为空，引用在初始化后不能更改所引用的变量目标，引用只能有一级。4.内存对齐问题 原因： 内存虽然以字节为单位，但并不是按照字节块来存取内存的，会以一定的内存粒度来存取（2、4字节等）。如果数据没有对齐可能会访问两次内存并作拼接处理，影响性能。 方法： 对于结构体的各个成员，第一个成员位于0的位置，结构体第一个成员的偏移量为0，以后的每个成员的offset都是该成员大小与有效对齐值中较小的那个的整数倍。 结构体本身的对齐：结构的长度是编译器默认的对齐长度和最长成员两者最下的数据大小的倍数。5.extern C 1. C++中调用C的函数，在头文件中使用。 extern C { fun1(parameter); }6.形参与实参 1. 形参只有在被调用时分配内存单元，调用结束后回收。所以形参只在函数内部有效。 2. 实参可以使常亮，变量，函数，表达式等，无论是何种类型，在进行函数调用时都必须有确定的值。 3. 函数调用过程中发生的数据传送是单向的，只能把实参的值传给形参。7.多态 1. 多态通过虚函数和虚函数表来实现。 在基类函数的前面加virtual关键字。在派生类中重写该函数。运行时会根据对象类型来调用相应的函数。 虚函数表：编译器为含有虚函数的类型自动生成虚函数表，在含有虚函数的类实例化对象时，对象地址的前四个字节存放指向虚表的指针。8.析构函数，构造函数，虚函数 1. 防止调用基类的析构函数无法完全析构派生类的状况，所以将基类的析构函数设置为虚函数，子类再定义自己的析构函数。 2. 构造函数不能为虚函数，但是在构造函数中可以调用虚函数，不过调用的是正在构造的类中的虚函数。9.纯虚函数 1. virtual solution()=0; 2. 含有纯虚函数的类为抽象类，无法被实例化，需要子类重写后实例化子类。 10.虚函数与虚表的存储位置 1. 虚函数表位于只读数据段，即常量区，虚函数位于代码段，也就是代码区。","link":"/2022/04/26/%E9%9D%A2%E7%BB%8F%E5%85%B6%E4%B8%80/"},{"title":"专业面面经汇总（2）","text":"专业面面经汇总（2）设计模式单例模式&ensp;&ensp;使用单例模式的类没有公开的构造函数，不能创造该类的实例。&ensp;&ensp;使用单例模式的类也没有公开的拷贝函数和赋值函数。&ensp;&ensp;使用单例模式的类需要提供一个公有方法，让外部可以访问唯一实例。 12345678910111213141516171819202122232425262728class singleton{ public: singleton* getinstance(); private: singleton(); singleton(const singleton&amp;); singleton &amp; operator = (const singleton &amp;); static singleton* _instance;} singleton* singleton::getinstance(){ if(_instance==nullptr){ _instance= new singleton; } }//懒汉模式 多线程不安全 class Singleton{public: Singleton*getInstance();private: Singleton(); Singleton(const Singleton&amp;); Singleton&amp; operator =(const Singleton&amp;); static Singleton _instance;};Singleton*Singleton::getInstance(){ return &amp;_instance;}//饿汉模式 一开始就对实例进行初始化 一个进程有几个堆和栈,什么时候用堆或栈&ensp;&ensp;一个进程有一个堆，多个栈（用户栈，内核栈）；&ensp;&ensp;一个线程只有一个栈，共享进程的堆；&ensp;&ensp;想要让资源的生命周期超过对应变量的作用域，就使用堆分配，如果资源大小只有在运行时知道，用堆分配。 new/delete与malloc区别&ensp;&ensp; new/delete是运算符，new自动计算所分配的空间大小，new 是类型安全的；会调用类的构造和析构函数。&ensp;&ensp; malloc/frees是标准库函数，需要手动分配内存大小并且是类型不安全的，返回的是空类型指针。 delete与delete[]&ensp;&ensp; delete针对单一对象的析构，而对于对象数组的析构需要使用delete[],析构顺序为逆序。delete[]可以通过前4个字节的大小类获取数组的大小。 什么时候调用拷贝构造函数&ensp;&ensp;用类的实例化对象去初始化另一个对象时。&ensp;&ensp;函数的参数是类的对象时，且为非引用传递。&ensp;&ensp;函数的返回值是函数体内局部对象的类的对象时。 浅拷贝与深拷贝&ensp;&ensp; 浅拷贝只拷贝一个指针，没有开辟新的地址，拷贝的指针和原来的指针指向同一块地址。&ensp;&ensp;深拷贝不仅拷贝值，还会开辟一块内存空间来存放新的值，即使原对象被析构，拷贝的值也不受影响。 面向对象的理解，多态？&ensp;&ensp;面向对象的思维模式更注重事件的参与者，需求里有哪些对象，这些对象对应的操作，实现一种高内聚低耦合的类型。把事物抽象为一种类型，类型拥有自己的属性和方法。&ensp;&ensp;多态通过虚函数和虚函数表来实现。在基类函数的前面加virtual关键字。在派生类中重写该函数。运行时会根据对象类型来调用相应的函数。虚函数表：编译器为含有虚函数的类型自动生成虚函数表，在含有虚函数的类实例化对象时，对象地址的前四个字节存放指向虚表的指针。 const int *p 与 int const * p 与 int *const p&ensp;&ensp; const int *p 与 int const * p无区别 都是 指针常量 ; p指向的为常量 即 *p 不能改变；&ensp;&ensp; int *const p 常量指针 const 修饰 指针p 即指针的值不能改变，且必须初始化。 冒泡排序，快速排序， 堆排序&ensp;&ensp; 冒泡排序： 结构为双层for()循环，平均时间复杂度为n^2, 空间为1 ， 稳定排序，最佳为n（有序）。&ensp;&ensp; 快速排序：递归实现，每个递归设边界值为初始值，平均，最佳时间复杂度nlogn， 最差为n2（基本有序），空间复杂度为logn；&ensp;&ensp; 堆排序：每个节点的子节点都小于父节点。建堆，交换，建堆循环。平均，最佳，最差都为nlogn，空间为1；（原地构造）","link":"/2022/04/26/%E9%9D%A22/"},{"title":"webserver项目描述","text":"Webserver 项目项目描述&ensp;&ensp; 为了贯穿学习的网络编程和Linux知识，从开源网站上选取了此项目进行学习和复现，实现了基于多路I/O复用epoll的HTTP服务器，实现了GET请求，访问静态资源。实现了基于STL容器的自动扩容的缓冲区，以及基于Thread类的线程池，使用lambda函数优化了线程池的性能，提高了效率，实现了基于堆排序的定时器，清理超时的服务器连接。 项目流程&ensp;&ensp; 启动server，主进程初始化socket连接和epoll类以及线程池，并将连接的描述符注册在epoll中，随后主进程进入循环，调用epoll_wait()函数获取准备就绪的fd列表。每一个客户端都拥有自己的httpconn类以及读写缓冲区，根据epoll返回的事件类型来调用不同的函数接口对缓冲区进行读写操作。&ensp;&ensp; 服务器解析HTTP请求时使用正则表达式进行请求行的分割，服务器通过哈希表对请求类型和对应的字符串进行保存。&ensp;&ensp; 每一个事件都会注册到线程池的任务队列中，默认线程池的线程数为4，通过互斥锁和条件变量进行同步。 项目改进&ensp;&ensp; 请求URL中包含了服务器的文件存储结构，没有进行安全处理。&ensp;&ensp; 加入日志和数据库操作。","link":"/2022/04/26/%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0/"}],"tags":[{"name":"慕课","slug":"慕课","link":"/tags/%E6%85%95%E8%AF%BE/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"}],"categories":[{"name":"专业课","slug":"专业课","link":"/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"笔试面试","slug":"笔试面试","link":"/categories/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"}]}